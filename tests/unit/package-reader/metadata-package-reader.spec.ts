import { Helpers } from '../../../src/internal/helpers';
import { MetadaPackageReader } from '../../../src/package-reader/metadata-package-reader';
import { TestCase } from '../../test-case';
/**
 * This tests uses the Zip file located at tests/_files/zip/metadata.zip that contains:
 *
 * __MACOSX/ // commonly generated by MacOS when open the file
 * __MACOSX/._45C5C344-DA01-497A-9271-5AA3852EE6AE_01.txt // commonly generated by MacOS when open the file
 * 00000000-0000-0000-0000-000000000000_00.txt // file with correct name but not a metadata file
 * 45C5C344-DA01-497A-9271-5AA3852EE6AE_01.txt // file with metadata 2 rows
 * empty-file // zero bytes file
 * other.txt // file with incorrect extension and incorrect content
 */
describe('metadata package reader', () => {
    test('count all contents', async () => {
        const expectedNumberFiles = 1;

        const filename = TestCase.filePath('zip/metadata.zip');
        const metadataPackageReader = await MetadaPackageReader.createFromFile(filename);

        expect(await metadataPackageReader.count()).toBe(expectedNumberFiles);
    });

    test('retrieve metadata contents', async () => {
        const filename = TestCase.filePath('zip/metadata.zip');
        const metadataPackageReader = await MetadaPackageReader.createFromFile(filename);
        const metadata = await Helpers.iteratorToMap(metadataPackageReader.metadata());

        expect(metadata.size).toBe(2);

        const extracted: string[] = [];
        metadata.forEach(item => {
            extracted.push(item.get('uuid'));
        });

        const expected = [
            'E7215E3B-2DC5-4A40-AB10-C902FF9258DF',
            '129C4D12-1415-4ACE-BE12-34E71C4EAB4E',
        ].sort();

        expect(extracted.sort()).toStrictEqual(expected);
    });

    test('create from file and contents', async () => {
        const filename = TestCase.filePath('zip/metadata.zip');
        const first = await MetadaPackageReader.createFromFile(filename);

        expect(first.getFilename()).toBe(filename);

        const contents = TestCase.fileContents('zip/metadata.zip');
        const second = await MetadaPackageReader.createFromContents(contents);
        const metadata1 = await Helpers.iteratorToMap(first.metadata());
        const metadata2 = await  Helpers.iteratorToMap(second.metadata());

        expect(metadata1).toStrictEqual(metadata2);
    });

    test('json', async () => {
        const zipFilename = TestCase.filePath('zip/metadata.zip');
        const packageReader = await MetadaPackageReader.createFromFile(zipFilename);

        // assert fileName
        const jsonData = await packageReader.jsonSerialize();
        expect(jsonData.source).toBe(zipFilename);

        // assert file contents
        const expectedFiles = [
            '45C5C344-DA01-497A-9271-5AA3852EE6AE_01.txt',
        ];
        const jsonDataFiles = jsonData.files;
        expect(Object.keys(jsonDataFiles)).toStrictEqual(expectedFiles);

        // assert metadataItems
        const expectedMetadata = [
            'E7215E3B-2DC5-4A40-AB10-C902FF9258DF',
            '129C4D12-1415-4ACE-BE12-34E71C4EAB4E',
        ];
        const jsonDataMetadata = jsonData.metadata;
        expect(Object.keys(jsonDataMetadata).sort()).toStrictEqual(expectedMetadata.sort());
    });
});
